import { validatePermission, validatePermissionSlugs } from "@/app/permissions";
// ImageData is a composite type that represents the data from both the
// image record in the database and minio object storage. It includes a

import {
  ALLOWED_IMAGE_FILE_TYPES,
  checkImageDate,
  checkImageDescription,
  checkImageTitle,
} from "@/validation/image_fields";
import {
  allNumbersValid,
  checkUuid,
  FieldValidation,
} from "@/validation/user_fields";
import { Permission } from "../permissions";
import { Album, validateAlbum } from "../albums";

// image data object -> metadata from pixie service
// signed URL for accessing the image, which is generated by the backend service.
export type ImageData = {
  id?: string; // Unique identifier for the image record
  title: string; // Title of the image
  description?: string; // Description of the image
  file_name?: string; // Name of the file with its extension, e.g., "slug.jpg"
  file_type?: string; // MIME type of the image, e.g., "image/jpeg", "image/png"
  object_key?: string; // The key used to store the image in object storage, e.g., "2025/slug.jpg"
  slug?: string; // ENCRYPTED: a unique slug for the image, used in URLs
  width?: number; // Width of the image in pixels
  height?: number; // Height of the image in pixels
  size?: number; // Size of the image file in bytes
  image_date?: string; // Date when the image was taken or created, i.e., from EXIF metadata
  created_at?: string; // Timestamp when the image was created
  updated_at?: string; // Timestamp when the image was last updated
  is_archived?: boolean; // Indicates if the image is archived
  is_published?: boolean; // Indicates if the image is published and visible to users

  image_targets?: ImageTarget[]; // Array of signed URLs for accessing the image in different sizes
  blur_url?: string; // A low-resolution, blurred version of the image for placeholder purposes
  // associated albums and permissions
  albums?: Album[]; // Array of albums the image belongs to
  permissions?: Permission[]; // Array of permissions associated with the image
};

export type ImageTarget = {
  width: number; // The width of the image in pixels
  signed_url: string; // The signed URL for the image, used to access the image in object storage
};

// Placeholder is a lightweight version of ImageData returned from an upload image request
export type Placeholder = {
  id?: string; // Unique identifier for the image record
  title: string; // Title of the image
  description?: string; // Description of the image
  file_name?: string; // Name of the file with its extension, e.g., "slug.jpg"
  file_type?: string; // MIME type of the image, e.g., "image/jpeg", "image/png"
  object_key?: string; // The key used to store the image in object storage, e.g., "2025/slug.jpg"
  slug?: string; // ENCRYPTED: a unique slug for the image, used in URLs
  width?: number; // Width of the image in pixels
  height?: number; // Height of the image in pixels
  size?: number; // Size of the image file in bytes
  image_date?: string; // Date when the image was taken or created, i.e., from EXIF metadata
  created_at?: string; // Timestamp when the image was created
  updated_at?: string; // Timestamp when the image was last updated
  is_archived?: boolean; // Indicates if the image is archived
  is_published?: boolean; // Indicates if the image is published and visible to users

  signed_url?: string;
};

export type AddImageCmd = {
  csrf: string | null;

  title: string;
  description: string;
  file_type: string;
  size: number;
  permissions: Permission[]; // Array of permissions to be applied to the image
  albums: Album[]; // Array of albums the image belongs to
};

// validate the metadata for the first stage of the image upload
export function validateImageData(data: AddImageCmd) {
  let errors: { [key: string]: string[] } = {};

  // validate csrf token
  if (
    data.csrf &&
    (data.csrf.trim().length < 16 || data.csrf.trim().length > 64)
  ) {
    errors.csrf = [
      "CSRF token is not well formed. This value cannot be edited or tampered with.",
    ];
  }

  // regex csrf check
  const checkCsrf = checkUuid(data.csrf ?? "");
  if (!checkCsrf.isValid) {
    errors.csrf = errors.csrf ?? [];
    errors.csrf.push(...checkCsrf.messages);
  }

  // validate title
  const checkTitle = checkImageTitle(data.title);
  if (!checkTitle.isValid) {
    errors.title = errors.title ?? [];
    errors.title.push(...checkTitle.messages);
  }

  // validate description
  const checkDescription = checkImageDescription(data.description);
  if (!checkDescription.isValid) {
    errors.description = errors.description ?? [];
    errors.description.push(...checkDescription.messages);
  }

  // validate content type
  if (!data.file_type || data.file_type.trim().length === 0) {
    errors.file = errors.file ?? [];
    errors.file.push("Content type is required.");
  }

  if (
    data.file_type &&
    data.file_type.trim().length > 0 &&
    !ALLOWED_IMAGE_FILE_TYPES.includes(data.file_type)
  ) {
    errors.file = errors.file ?? [];
    errors.file.push(
      `Content type must be one of the following: ${ALLOWED_IMAGE_FILE_TYPES.join(
        ", "
      )}.`
    );
  }

  // validate file size
  if (!data.size || data.size <= 0) {
    errors.file = errors.file ?? [];
    errors.file_size = ["File size is required and must be greater than 0."];
  } else if (data.size > 10 * 1024 * 1024) {
    // 10 MB limit
    errors.file = errors.file ?? [];
    errors.file = ["File size must not exceed 10 MB."];
  }

  // it is not required to add permissions at this stage.
  if (data.permissions && data.permissions.length > 0) {
    data.permissions.forEach((permission) => {
      // validate permission object
      const errs = validatePermission(permission);
      if (Object.keys(errs).length > 0) {
        errors.permissions = errors.permissions ?? [];
        errors.permissions.push(
          `Permission ${permission.slug} has errors: ${Object.values(errs)
            .flat()
            .join(", ")}`
        );
      }
    });
  }

  // it is not required to add albums at this stage
  // but if they are provided, validate them
  if (data.albums && data.albums.length > 0) {
    data.albums.forEach((album) => {
      // validate album object
      const errs = validateAlbum(album);
      if (Object.keys(errs).length > 0) {
        errors.albums = errors.albums ?? [];
        errors.albums.push(
          `Album ${album.slug} has errors: ${Object.values(errs)
            .flat()
            .join(", ")}`
        );
      }
    });
  }

  return errors;
}

// ImageActionCmd is the command object for updating an image's metadata.
export type ImageActionCmd = {
  csrf: string | null; // CSRF token for form submission
  slug: string | null; // Unique identifier for the image, used in URLs
  updateCmd: UpdateImageCmd | null; // The image data to be updated or created
  errors: { [key: string]: string[] }; // Validation errors, if any
};

export type UpdateImageCmd = {
  csrf: string | null; // CSRF token for form submission
  slug: string | null; // Unique identifier for the image, used in URLs
  title: string; // Title of the image
  description?: string; // Description of the image
  image_date_month?: number; // month when the image was taken
  image_date_day?: number; // day when the image was taken
  image_date_year?: number; // year when the image was taken
  is_published?: boolean; // Indicates if the image is published
  is_archived?: boolean; // Indicates if the image is archived

  albums?: Album[]; // Array of albums the image belongs to for edit requests
  permissions?: Permission[]; // Array of permissions to be applied to the image for edit requests

  // captures the slugs of associated albums and permissions for edit requests
  album_slugs?: string[]; // Array of albums the image belongs to
  permission_slugs?: string[]; // Array of permissions to be applied to the image
};

export function validateUpdateImageCmd(image: UpdateImageCmd): {
  [key: string]: string[];
} {
  let errors: { [key: string]: string[] } = {};

  // validate csrf token
  if (
    image.csrf &&
    (image.csrf.trim().length < 16 || image.csrf.trim().length > 64)
  ) {
    errors.csrf = [
      "CSRF token is not well formed. This value cannot be edited or tampered with.",
    ];
  }

  // regex csrf check
  const checkCsrf = checkUuid(image.csrf ?? "");
  if (!checkCsrf.isValid) {
    errors.csrf = errors.csrf ?? [];
    errors.csrf.push(...checkCsrf.messages);
  }

  // validate slug
  if (
    !image.slug ||
    image.slug.trim().length < 16 ||
    image.slug.trim().length > 64
  ) {
    errors.slug = ["Slug is required and must be well formed."];
  }

  // validate title
  const checkTitle = checkImageTitle(image.title);
  if (!checkTitle.isValid) {
    errors.title = errors.title ?? [];
    errors.title.push(...checkTitle.messages);
  }

  // validate description
  if (!image.description) {
    image.description = "";
  }
  const checkDescription = checkImageDescription(image.description);
  if (!checkDescription.isValid) {
    errors.description = errors.description ?? [];
    errors.description.push(...checkDescription.messages);
  }

  // first need to check if all fields are filled out
  if (
    (image.image_date_month &&
      !isNaN(image.image_date_month) &&
      !allNumbersValid(image.image_date_day, image.image_date_year)) ||
    (image.image_date_day &&
      !isNaN(image.image_date_day) &&
      !allNumbersValid(image.image_date_month, image.image_date_year)) ||
    (image.image_date_year &&
      !isNaN(image.image_date_year) &&
      !allNumbersValid(image.image_date_month, image.image_date_day))
  ) {
    errors.birthdate = ["Please fill out all date fields."];
    if (!image.image_date_month) {
      errors.image_date.push("Month is required.");
    }
    if (!image.image_date_day) {
      errors.image_date.push("Day is required.");
    }
    if (!image.image_date_year) {
      errors.image_date.push("Year is required.");
    }
  }

  // only check if all image_date_* fields are filled out
  if (image.image_date_month && image.image_date_day && image.image_date_year) {
    // check if image_date_* is valid
    const imageDate: FieldValidation = checkImageDate(
      image.image_date_year,
      image.image_date_month,
      image.image_date_day
    );
    if (!imageDate.isValid) {
      errors.image_date = imageDate.messages;
    }
  }

  // validate is_published checkbox and is_archived checkbox not checked at the same time
  if (image.is_published && image.is_archived) {
    errors.checkboxes = [
      "Image cannot be both published and archived at the same time.",
    ];
  }

  // check album slugs provided, if any
  if (image.album_slugs && image.album_slugs.length > 0) {
    image.album_slugs.forEach((slug) => {
      const checkSlug = checkUuid(slug);
      if (!checkSlug.isValid) {
        if (Object.keys(errors).length > 0) {
          errors.albums = errors.albums ?? [];
          errors.albums.push(
            `Album ${slug} has errors: ${Object.values(checkSlug.messages)
              .flat()
              .join(", ")}`
          );
        }
      }
    });
  }

  // check permission slugs provided, if any
  if (image.permission_slugs && image.permission_slugs.length > 0) {
    image.permission_slugs.forEach((slug) => {
      const checkSlug = checkUuid(slug);
      if (!checkSlug.isValid) {
        if (Object.keys(errors).length > 0) {
          errors.permissions = errors.permissions ?? [];
          errors.permissions.push(
            `Permission ${slug} has errors: ${Object.values(checkSlug.messages)
              .flat()
              .join(", ")}`
          );
        }
      }
    });
  }

  return errors;
}
